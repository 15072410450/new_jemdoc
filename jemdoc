#!/usr/bin/env python

import sys
import re
import time

# better checking of arguments?

try:
    inname = sys.argv[1]
except IndexError:
    inname = '--help'

if inname == '--help' or inname =='-h':
    print 'Usage: jemdoc INPUTNAME [-o OUTPUTNAME] [-c CONFIG1] [-c CONFIG2]...'
    print 'Produces html markup from jemdoc input.'
    print
    print 'OUTPUTNAME defaults to INPUTNAME, minus extension, plus html.'
    print
    print 'CONFIG1 defaults to ./jemdoc.conf. Multiple CONFIG files are'
    print 'treated in priority order from left to right.'
    print
    print 'See http://jemdoc.jaboc.net/ for a few more details.'
    print
    raise SystemExit

if len(sys.argv[2:]) % 2 != 0:
    raise RuntimeError('invalid arguments, try --help')

outname = inname.rsplit('.', 1)[0] + '.html'
outoverride = False
confnames = []
for i in range(2, len(sys.argv), 2):
    if sys.argv[i] == '-o':
        if outoverride:
            raise RuntimeError('cannot specify two output filenames')
        outname = sys.argv[i+1]
        outoverride = True
    elif sys.argv[i] == '-c':
        confnames.append(sys.argv[i+1])
    else:
        raise RuntimeError('unrecognised argument %s, try --help' % sys.argv[i])

if not confnames:
    confnames = ['jemdoc.conf'] # have internal configuration file?

def readnoncomment(f):
    l = f.readline()
    if l == '':
        return l
    elif l[0] == '#': # jem: be a little more generous with the comments we accept?
        return readnoncomment(f)
    else:
        return l.rstrip() + '\n' # leave just one \n and no spaces etc.

def parseconf(cns):
    syntax = {}
    warn = False # jem. make configurable?
    for sname in cns:
        f = open(sname)
        while pc(f) != '':
            l = readnoncomment(f)
            r = re.match(r'\[(.*)\]\n', l)

            if r:
                tag = r.group(1)
                if tag in syntax:
                    if warn:
                        print 'Warning: ignoring redefinition of %s.' % tag
                    continue

                s = ''
                l = readnoncomment(f)
                while l not in ('\n', ''):
                    s += l
                    l = readnoncomment(f)

                syntax[tag] = s

        f.close()

    return syntax

def insertmenuitems(mname, current):
    f = open(mname)
    while pc(f) != '':
        l = readnoncomment(f)
        l = l.strip()
        if l == '':
            continue

        r = re.match(r'\s*(.*?)\s*\[(.*)\]', l)

        if r: # then we have a link.
            if r.group(2) == current: 
                hb(conf['currentmenuitem'], r.group(2), br(r.group(1)))
            else:
                hb(conf['menuitem'], r.group(2), br(r.group(1)))

        else: # menu category.
            hb(conf['menucategory'], br(l))

    f.close()


infile = open(inname)
outfile = open(outname, 'w')

def out(s):
    outfile.write(s)

def hb(tag, content1, content2=None):
    """Writes out a halfblock (hb)."""
    if content2 is None:
        out(re.sub(r'\|', content1, tag))
    else:
        r = re.sub(r'\|1', content1, tag)
        r = re.sub(r'\|2', content2, r)
        out(r)

def pc(f = infile):
    """Peeks at next character in the file."""
    # Should only be used to look at the first character of a new line.
    c = f.read(1)
    if c: # only undo forward movement if we're not at the end.
        #if c == '#': # interpret comment lines as blank.
        #    return '\n'

        if c in ' \t':
            return pc()

        f.seek(-1, 1)

    return c

def nl(withcount=False, codemode=False):
    global linenum
    """Get input file line."""
    s = infile.readline()
    linenum += 1
    if not codemode:
        # remove any special characters - assume they were checked by pc() before
        # we got here.
        # remove any trailing comments.
        s = s.lstrip(' \t')
        s = re.sub(r'\s*(?<!\\)#.*', '', s)

    if withcount:
        if s[0] == '.':
            m = r'\.'
        else:
            m = s[0]

        r = re.match('(%s+) ' % m, s)
        if not r:
            raise SyntaxError('error (code 12039) on line %d' % linenum)

        if not codemode:
            s = s.lstrip('-.=')

        return (s, len(r.group(1)))
    else:
        if not codemode:
            s = s.lstrip('-.=')

        return s

def np(withcount=False):
    """Gets the next paragraph from the input file."""
    # New paragraph markers signalled by characters in following tuple.
    if withcount:
        (s, c) = nl(withcount)
    else:
        s = nl()

    while pc() not in ('\n', '-', '.', '', '=', '#', '~', '{'):
        s += nl()

    while pc() == '\n':
        nl() # burn blank line.

    # in both cases, ditch the trailing \n.
    if withcount:
        return (s[:-1], c)
    else:
        return s[:-1]

def quote(s):
    return re.sub(r"""[\\*/+"'<>\.~[\]]""", r'\\\g<0>', s)

def replacequoted(b):
    r = re.compile(r'(?<!\\){{(.*?)(?<!\\)}}', re.M + re.S)
    m = r.search(b)
    while m:
        qb = quote(m.group(1))

        b = b[:m.start()] + qb + b[m.end():]

        m = r.search(b, m.start())

    return b

def replacelinks(b):
    # works with [link.html new link style].
    r = re.compile(r'(?<!\\)\[(.*?)(?:\s(.*?))?(?<!\\)\]', re.M + re.S)
    m = r.search(b)
    while m:
        m1 = m.group(1).strip()

        if '@' in m1 and not m1.startswith('mailto:'):
            link = 'mailto:' + m1
        else:
            link = m1

        link = quote(link)

        if m.group(2):
            linkname = m.group(2).strip()
        else:
            # remove any mailto before labelling.
            linkname = re.sub('^mailto:', '', link)

        b = b[:m.start()] + r'<a href=\"%s\">%s<\/a>' % (link, linkname) + b[m.end():]

        m = r.search(b, m.start())

    return b

def br(b):
    """Does simple text replacements on a block of text. ('block replacements')"""
    # Deal with {{html embedding}}.
    b = replacequoted(b)

    b = allreplace(b)

    # First do the URL thing.
    b = b.lstrip('-. \t') # remove leading spaces, tabs, dashes, dots.
    b = replacelinks(b)


    # Deal with /italics/ first because the '/' in other tags would otherwise
    # interfere.
    r = re.compile(r'(?<!\\)/(.*?)(?<!\\)/', re.M + re.S)
    b = re.sub(r, r'<i>\1</i>', b)

    # Deal with *bold*.
    r = re.compile(r'(?<!\\)\*(.*?)(?<!\\)\*', re.M + re.S)
    b = re.sub(r, r'<b>\1</b>', b)

    # Deal with +monospace+.
    r = re.compile(r'(?<!\\)\+(.*?)(?<!\\)\+', re.M + re.S)
    b = re.sub(r, r'<tt>\1</tt>', b)

    # Deal with "double quotes".
    r = re.compile(r'(?<!\\)"(.*?)(?<!\\)"', re.M + re.S)
    b = re.sub(r, r'&ldquo;\1&rdquo;', b)

    # Deal with left quote `.
    r = re.compile(r"(?<!\\)`", re.M + re.S)
    b = re.sub(r, r'&lsquo;', b)

    # Deal with apostrophe '.
    r = re.compile(r"(?<!\\)'", re.M + re.S)
    b = re.sub(r, r'&rsquo;', b)

    # Deal with em dash ---.
    r = re.compile(r"(?<!\\)---", re.M + re.S)
    b = re.sub(r, r'&mdash;', b)

    # Deal with en dash --.
    r = re.compile(r"(?<!\\)--", re.M + re.S)
    b = re.sub(r, r'&ndash;', b)

    # Deal with ellipsis  ....
    r = re.compile(r"(?<!\\)\.\.\.", re.M + re.S)
    b = re.sub(r, r'&hellip;', b)

    # Deal with non-breaking space ~.
    r = re.compile(r"(?<!\\)~", re.M + re.S)
    b = re.sub(r, r'&nbsp;', b)

    # Deal with line break.
    r = re.compile(r"(?<!\\)\\n", re.M + re.S)
    b = re.sub(r, r'<br />', b)

    # Deal with registered trademark \R.
    r = re.compile(r"(?<!\\)\\R", re.M + re.S)
    b = re.sub(r, r'&reg;', b)

    # Deal with copyright \C.
    r = re.compile(r"(?<!\\)\\C", re.M + re.S)
    b = re.sub(r, r'&copy;', b)

    # Last remove any remaining quoting backslashes.
    b = re.sub(r'\\([^\\])', r'\1', b)

    return b

def allreplace(b):
    """Replacements that should be done on everything."""
    r = re.compile(r"(?<!\\)>", re.M + re.S)
    b = re.sub(r, r'&gt;', b)

    r = re.compile(r"(?<!\\)<", re.M + re.S)
    b = re.sub(r, r'&lt;', b)

    r = re.compile(r"\\~", re.M + re.S)
    b = re.sub(r, r'~', b)

    return b

# load the conf.
conf = parseconf(confnames)

# Get the file started with the firstbit.
out(conf['firstbit'])

linenum = 0

menu = None
footer = True
if pc() == '#':
    l = infile.readline()
    linenum += 1
    if l.startswith('# jemdoc: '):
        l = l[len('# jemdoc: '):]
        a = l.split(',')
        # jem only handle one argument for now.
        b = a[0].strip()
        if b.startswith('menu'):
            sidemenu = True
            r = re.compile(r'(?<!\\){(.*?)(?<!\\)}', re.M + re.S)
            g = re.findall(r, l)
            if len(g) != 2:
                raise SyntaxError('sidemenu error on line %d' % linenum)

            menu = (g[0], g[1])

        try:
            b = a[1].strip()
            if b.startswith('nodate'):
                footer = False
        except IndexError:
            pass

# Look for a title.
if pc() == '=': # don't check exact number of '=' here jem.
    t = br(nl())[:-1]
    hb(conf['windowtitle'], t)
    out(conf['bodystart'])

else:
    out(conf['bodystart'])
    t = None

if menu:
    out(conf['menustart'])
    insertmenuitems(*menu)
    out(conf['menuend'])
else:
    out(conf['nomenu'])

if t is not None:
    hb(conf['doctitle'], t)

    # Look for a subtitle.
    if pc() != '\n':
        hb(conf['subtitle'], br(np()))

def pyint(l):
    l = l.rstrip()
    if l.startswith('>>>'):
        hb('<span class="pycommand">|</span>\n', allreplace(l))
    elif l.startswith('#'): # jem upgrade this to handle not at the beginning.
        hb('<span class="comment">|</span>\n', allreplace(l))
    else:
        out(allreplace(l) + '\n')

def py(l):
    # jem need to do much better here.
    l = l.rstrip()
    if l.startswith('>>>'):
        hb('<span class="pycommand">|</span>\n', allreplace(l))
    elif l.startswith('#'):
        hb('<span class="comment">|</span>\n', allreplace(l))
    else:
        out(allreplace(l) + '\n')


infoblock = False
while 1: # wait for EOF.
    p = pc()

    if p == '':
        break

    # look for lists.
    elif p == '-':
        level = 0

        while pc() == '-':
            (s, newlevel) = np(True)

            # first adjust list number as appropriate.
            if newlevel > level:
                for i in range(newlevel - level):
                    if newlevel > 1:
                        out('\n')
                    out('<ul>\n<li>')
            elif newlevel < level:
                for i in range(level - newlevel):
                    out('</li>\n</ul>\n</li><li>')
            else:
                out('</li>\n<li>')

            out(br(s))
            level = newlevel

        for i in range(level):
            out('</li>\n</ul>\n')

    elif p == '.':
        level = 0

        while pc() == '.':
            (s, newlevel) = np(True)

            # first adjust list number as appropriate.
            if newlevel > level:
                for i in range(newlevel - level):
                    if newlevel > 1:
                        out('\n')
                    out('<ol>\n<li>')
            elif newlevel < level:
                for i in range(level - newlevel):
                    out('</li>\n</ol>\n</li><li>')
            else:
                out('</li>\n<li>')

            out(br(s))
            level = newlevel

        for i in range(level):
            out('</li>\n</ol>\n')

    # look for titles.
    elif p == '=':
        (s, c) = nl(True)
        # trim trailing \n.
        s = s[:-1]
        hb('<h%d>|</h%d>\n' % (c, c), br(s))

    # look for comments.
    elif p == '#':
        nl()

    elif p == '\n':
        nl()

    # look for blocks.
    elif p == '~':
        nl()
        if infoblock:
            out(conf['infoblockend'])
            infoblock = False
            nl()
            continue
        else:
            if pc() == '{':
                l = br(nl())
                r = re.compile(r'(?<!\\){(.*?)(?<!\\)}', re.M + re.S)
                g = re.findall(r, l)
            else:
                g = []

            if len(g) in (0, 1): # info block.
                out(conf['infoblock'])
                infoblock = True
                
                if len(g) == 1: # info block.
                    hb(conf['blocktitle'], g[0])

                out(conf['infoblockcontent'])

            elif len(g) == 2: # code block.
                out(conf['codeblock'])
                if len(g[0]):
                    hb(conf['blocktitle'], g[0])
                out(conf['codeblockcontent'])

                if g[1] not in ('', 'pyint', 'py'):
                    raise SyntaxError('unrecognised syntax '
                                      'highlighting on line %d' % linenum)

                # Now we are handling code.
                # Handle \~ and ~ differently.
                while 1: # wait for EOF.
                    l = nl(codemode=True)
                    if not l:
                        break
                    elif l.startswith('~'):
                        break
                    elif l.startswith('\\~'):
                        l = l[1:]

                    if g[1] == 'pyint':
                        pyint(l)
                    elif g[1] == 'py':
                        py(l)
                    else:
                        out(allreplace(l))

                out(conf['codeblockend'])
            else:
                raise SyntaxError('error (code 0192977) on line %d' % linenum)

    else:
        s = br(np())
        if s:
            hb('<p>|</p>\n', s)

if footer:
    s = time.strftime('%F %R:%S %Z', time.localtime(time.time()))
    out(conf['footerstart'])
    hb(conf['lastupdated'], s)
    out(conf['footerend'])

if menu:
    out(conf['menulastbit'])
else:
    out(conf['nomenulastbit'])

if outfile is not sys.stdout:
    outfile.close()
